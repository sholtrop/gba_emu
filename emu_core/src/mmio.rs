use modular_bitfield::{bitfield, specifiers::*, BitfieldSpecifier};
use std::mem::size_of;

use crate::{
    bus::Bus,
    cycles::Cycles,
    memcontroller::{shared, Shared},
};

/// We use this trait to reinterpret bytes of [IoRam] as bitfield structs that are more easily accessed.
/// The CPU can simply write [IoRam] as if it were an array of u8's. The emulator's other hardware can
/// access [IoRam] as a collection of bitfield structs.
pub trait MmioRegister {
    const START_ADDR: usize;
    const END_ADDR: usize;

    /// Type that all registers between START_ADDR and END_ADDR combined will have. Should be an array
    /// if the the range START_ADDR..=END_ADDR contains multiple registers.
    type Out;

    /// Convert a buffer of bytes into the desired [MmioRegister] (or multiple [MmioRegister]s).
    fn from_bytes(bytes: &[u8]) -> Self::Out;
}

pub(crate) mod graphics {
    #![allow(dead_code)]
    // for associated functions generated by `bitfield`
    use super::*;
    /// Memory-mapped hardware registers:
    /// https://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Memory-Mapped%20Hardware%20Registers

    /// Video mode determines how the GBA draws on the screen:
    /// https://www.cs.rit.edu/~tjh8300/CowBite/CowBiteSpec.htm#Mode%200
    #[derive(BitfieldSpecifier, Debug, PartialEq, Eq)]
    #[bits = 3]
    pub enum VideoMode {
        Mode0 = 0b000,
        Mode1 = 0b001,
        Mode2 = 0b010,
        Mode3 = 0b011,
        Mode4 = 0b100,
        Mode5 = 0b101,
    }

    #[bitfield(bits = 16)]
    #[derive(Debug, Clone, Copy)]
    pub struct DisplayControlRegister {
        pub video_mode: VideoMode,
        pub gbc_mode: B1, // Read only - stays at 0
        pub page_flip: B1,
        pub force_hblank_processing: B1,
        pub vram_sprite_dims: B1, // 1 = 1d, 0 = 2d
        pub force_blank_display: B1,
        pub display_bg0: B1,
        pub display_bg1: B1,
        pub display_bg2: B1,
        pub display_bg3: B1,
        pub display_oam: B1,
        pub window0_enabled: B1,
        pub window1_enabled: B1,
        pub sprite_windows_enabled: B1,
    }

    impl MmioRegister for DisplayControlRegister {
        // Address: 0x4000000
        const START_ADDR: usize = 0x0;
        const END_ADDR: usize = Self::START_ADDR + size_of::<Self>();
        type Out = Self;

        fn from_bytes(bytes: &[u8]) -> Self::Out {
            Self::from_bytes(bytes.try_into().unwrap())
        }
    }

    #[bitfield(bits = 16)]
    #[derive(Debug)]
    pub struct DisplayStatusRegister {
        pub v_refresh_status: B1,        // readonly
        pub h_refresh_status: B1,        // readonly
        pub vcount_triggered_status: B1, // 1 on Y trigger interrupts, readonly
        pub vblank_irq: B1,
        pub hblank_irq: B1,
        pub vcount_trigger: B1,
        #[skip]
        ignored: B2,
        pub vcount_line_trigger: B8,
    }

    impl MmioRegister for DisplayStatusRegister {
        // Address: 0x4000004
        const START_ADDR: usize = 0x4;
        const END_ADDR: usize = Self::START_ADDR + size_of::<Self>();
        type Out = Self;

        fn from_bytes(bytes: &[u8]) -> Self::Out {
            Self::from_bytes(bytes.try_into().unwrap())
        }
    }

    #[bitfield(bits = 16)]
    #[derive(BitfieldSpecifier, Debug)]
    pub struct VCount {
        pub vcount: u8,
        #[skip]
        ignored: B8,
    }

    impl MmioRegister for VCount {
        // Address: 0x4000006
        const START_ADDR: usize = 0x6;
        const END_ADDR: usize = Self::START_ADDR + size_of::<Self>();
        type Out = Self;

        fn from_bytes(bytes: &[u8]) -> Self::Out {
            Self::from_bytes(bytes.try_into().unwrap())
        }
    }
}

pub(crate) mod background {
    #![allow(dead_code)]

    use crate::memcontroller::KB;

    // for associated functions generated by `bitfield`
    use super::*;

    #[derive(Debug, BitfieldSpecifier)]
    pub enum TileMapSize {
        Size0,
        Size1,
        Size2,
        Size3,
    }

    impl TileMapSize {
        /// Size of the BG map area for [VideoMode::Mode0] and [VideoMode::Mode1]
        pub fn text_mode_size(&self) -> usize {
            match self {
                Size0 => 2 * KB,
                Size1 => 4 * KB,
                Size2 => 4 * KB,
                Size3 => 8 * KB,
            }
        }

        /// Size of the BG map area for [VideoMode::Mode2], and first two layers of [VideoMode::Mode1]
        pub fn rotscale_mode_size(&self) -> usize {
            match self {
                Size0 => 256,
                Size1 => KB,
                Size2 => 4 * KB,
                Size3 => 16 * KB,
            }
        }
    }

    // Address: 0x4000008 - REG_BG0CNT
    // Address: 0x400000A - REG_BG1CNT
    // Address: 0x400000C - REG_BG2CNT
    // Address: 0x400000E - REG_BG3CNT
    #[bitfield(bits = 16)]
    #[derive(Debug, BitfieldSpecifier, Clone, Copy)]
    pub struct BgControlRegister {
        pub priority: B2,
        pub char_base_block: B2,
        #[skip]
        ignored: B2,
        pub mosaic_effect: B1,
        pub color_palette_type: B1,
        pub screen_base_block: B5,
        pub screen_over: B1,
        // For "text" backgrounds:
        // 00 : 256x256 (32x32 tiles)
        // 01 : 512x256 (64x32 tiles)
        // 10 : 256x512 (32x64 tiles)
        // 11 : 512x512 (64x64 tiles)
        //
        // For rotational backgrounds:
        // 00 : 128x128 (16x16 tiles)
        // 01 : 256x256 (32x32 tiles)
        // 10 : 512x512 (64x64 tiles)
        // 11 : 1024x1024 (128x128 tiles)
        pub tile_map_size: TileMapSize,
    }

    impl MmioRegister for BgControlRegister {
        const START_ADDR: usize = 0x8;
        const END_ADDR: usize = Self::START_ADDR + 4 * size_of::<Self>();
        type Out = [Self; 4];

        fn from_bytes(bytes: &[u8]) -> Self::Out {
            [
                Self::from_bytes(bytes[0..2].try_into().unwrap()),
                Self::from_bytes(bytes[2..4].try_into().unwrap()),
                Self::from_bytes(bytes[4..6].try_into().unwrap()),
                Self::from_bytes(bytes[6..8].try_into().unwrap()),
            ]
        }
    }

    // Address: 0x4000010 - REG_BG0HOFS Horizontal scroll co-ordinate for BG0 (Write Only)
    // Address: 0x4000012 - REG_BG0VOFS Vertical scroll co-ordinate for BG0 (Write Only)
    // Address: 0x4000014 - REG_BG1HOFS Horizontal scroll co-ordinate for BG1 (Write Only)
    // Address: 0x4000016 - REG_BG1VOFS Vertical scroll co-ordinate for BG1 (Write Only)
    // Address: 0x4000018 - REG_BG2HOFS Horizontal scroll co-ordinate for BG2 (Write Only)
    // Address: 0x400001A - REG_BG2VOFS Vertical scroll co-ordinate for BG2 (Write Only)
    // Address: 0x400001C - REG_BG3HOFS Horizontal scroll co-ordinate for BG3 (Write Only)
    // Address: 0x400001E - REG_BG3VOFS Vertical scroll co-ordinate for BG3 (Write Only)

    #[bitfield(bits = 32)]
    #[derive(Debug, BitfieldSpecifier)]
    pub struct BgScrollDoubleReg {
        pub x_offset: ScrollCoordinate,
        pub y_offset: ScrollCoordinate,
    }

    impl MmioRegister for BgScrollDoubleReg {
        const START_ADDR: usize = 0x10;
        const END_ADDR: usize = Self::START_ADDR + 4 * size_of::<Self>();
        type Out = [Self; 4];
        fn from_bytes(bytes: &[u8]) -> Self::Out {
            [
                Self::from_bytes(bytes[0..2].try_into().unwrap()),
                Self::from_bytes(bytes[2..4].try_into().unwrap()),
                Self::from_bytes(bytes[4..6].try_into().unwrap()),
                Self::from_bytes(bytes[6..8].try_into().unwrap()),
            ]
        }
    }

    #[bitfield(bits = 16)]
    #[derive(Debug, BitfieldSpecifier)]
    pub struct ScrollCoordinate {
        coord: B9,
        #[skip]
        ignored: B7,
    }

    /// Background Rotation/Scaling Registers (Write Only)
    #[bitfield(bits = 16)]
    #[derive(Debug, BitfieldSpecifier)]
    pub struct BgRotScaleRegister {
        pub fraction: B8,
        pub integer: B7,
        pub sign: B1,
    }

    impl MmioRegister for BgRotScaleRegister {
        const START_ADDR: usize = 0x20;
        const END_ADDR: usize = Self::START_ADDR + 4 * size_of::<Self>();
        type Out = [Self; 4];

        fn from_bytes(bytes: &[u8]) -> Self::Out {
            [
                Self::from_bytes(bytes[0..2].try_into().unwrap()),
                Self::from_bytes(bytes[2..4].try_into().unwrap()),
                Self::from_bytes(bytes[4..6].try_into().unwrap()),
                Self::from_bytes(bytes[6..8].try_into().unwrap()),
            ]
        }
    }

    #[bitfield(bits = 32)]
    #[derive(Debug, BitfieldSpecifier)]
    pub struct BgRefPoint {
        pub frac_portion: B8,
        pub int_portion: B19,
        pub sign: B1,
        #[skip]
        ignored: B4,
    }

    impl MmioRegister for BgRefPoint {
        const START_ADDR: usize = 0x28;
        const END_ADDR: usize = Self::START_ADDR + 2 * size_of::<Self>();
        type Out = [Self; 2];

        fn from_bytes(bytes: &[u8]) -> Self::Out {
            [
                Self::from_bytes(bytes[0..1].try_into().unwrap()),
                Self::from_bytes(bytes[1..2].try_into().unwrap()),
            ]
        }
    }
}

pub(crate) mod windowing {
    // Address: 0x4000040 - REG_WIN0H (Window 0 X Coordinates) (Write Only)
    // Address: 0x4000042 - REG_WIN1H (Window 1 X Coordinates)(Write Only)
    #[derive(Debug)]
    pub struct WindowXCoordinates {
        right: u8, // X coordinate for the rightmost side of the window
        left: u8,  // X coordinate for the leftmost side of the window
    }

    // Address: 0x4000044 - REG_WIN0V (Window 0 Y Coordinates) (Write Only)
    // Address: 0x4000046 - REG_WIN1V (Window 1 Y Coordinates)(Write Only)
    #[derive(Debug)]
    pub struct WindowYCoordinates {
        bottom: u8, // Y coordinate for the bottom of the window
        top: u8,    // Y coordinate for the top of the window
    }
}

use background::*;
use graphics::*;
use windowing::*;

const IO_RAM_SIZE: usize = 0x3fe;

#[derive(Debug)]
pub struct IoRam {
    mem: Box<[u8; IO_RAM_SIZE]>,
}

impl IoRam {
    pub fn new_shared() -> Shared<IoRam> {
        shared(IoRam {
            mem: Box::new([0; IO_RAM_SIZE]),
        })
    }

    pub fn read_mmio_reg<T: MmioRegister>(&self) -> T::Out {
        let bytes = &self.mem[T::START_ADDR..T::END_ADDR];
        T::from_bytes(bytes)
    }
}

impl Bus for IoRam {
    fn read<const SIZE: usize>(&self, address: u32) -> ([u8; SIZE], Cycles) {
        let address = address as usize;
        let range = address..(address + SIZE);
        let val: [u8; SIZE] = self.mem[range].try_into().unwrap();
        (val, Cycles(0))
    }

    fn write<const SIZE: usize>(&mut self, address: u32, val: &[u8; SIZE]) -> Cycles {
        let address = address as usize;
        let range = address..(address + SIZE);
        self.mem[range].copy_from_slice(val);
        Cycles(0)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_read_mmio_reg() {
        let mmio = IoRam::new_shared();
        mmio.borrow_mut().write_le_halfword(
            DisplayControlRegister::START_ADDR as u32,
            0b1111_0101_0000_0011,
        );
        let disp_cont: DisplayControlRegister =
            mmio.borrow().read_mmio_reg::<DisplayControlRegister>();
        dbg!(&disp_cont);
        dbg!(disp_cont.into_bytes());

        assert_eq!(disp_cont.force_blank_display(), 0);
        assert_eq!(disp_cont.vram_sprite_dims(), 0);
        assert_eq!(disp_cont.force_hblank_processing(), 0);
        assert_eq!(disp_cont.page_flip(), 0);

        assert_eq!(disp_cont.gbc_mode(), 0);
        assert_eq!(disp_cont.video_mode(), VideoMode::Mode3);

        assert_eq!(disp_cont.sprite_windows_enabled(), 1);
        assert_eq!(disp_cont.window1_enabled(), 1);
        assert_eq!(disp_cont.window0_enabled(), 1);
        assert_eq!(disp_cont.display_oam(), 1);

        assert_eq!(disp_cont.display_bg3(), 0);
        assert_eq!(disp_cont.display_bg2(), 1);
        assert_eq!(disp_cont.display_bg1(), 0);
        assert_eq!(disp_cont.display_bg0(), 1);
    }
}
